<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Twevals Results</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Visual indicators for sort direction on headers */
      #results-table thead th[aria-sort="ascending"]::after {
        content: " ▲";
        font-size: 0.75rem; /* text-sm */
        color: #6b7280; /* gray-500 */
      }
      #results-table thead th[aria-sort="descending"]::after {
        content: " ▼";
        font-size: 0.75rem; /* text-sm */
        color: #6b7280; /* gray-500 */
      }
      /* Column resizer handle */
      #results-table thead th .col-resizer {
        position: absolute;
        right: 0;
        top: 0;
        width: 6px;
        height: 100%;
        cursor: col-resize;
        user-select: none;
      }
      #results-table thead th .col-resizer:hover {
        background: linear-gradient(to right, transparent, rgba(0,0,0,0.05));
      }
      body.twevals-col-resize {
        cursor: col-resize !important;
      }
    </style>
  </head>
  <body class="p-4">
    <div class="flex items-center gap-2 mb-4">
      <h1 class="text-2xl font-bold mr-auto">Twevals Results</h1>
      <button
        id="export-json"
        class="px-3 py-2 bg-gray-100 text-gray-700 border rounded"
        title="Download results as JSON"
      >
        Export JSON
      </button>
      <button
        id="export-csv"
        class="px-3 py-2 bg-gray-100 text-gray-700 border rounded"
        title="Download results as CSV"
      >
        Export CSV
      </button>
      <button
        class="px-4 py-2 bg-blue-500 text-white rounded"
        hx-get="/results"
        hx-target="#results"
        hx-swap="innerHTML"
      >
        Refresh
      </button>
      <div class="relative">
        <button id="columns-toggle" class="px-3 py-2 bg-gray-100 border rounded">
          Columns ▾
        </button>
        <div
          id="columns-menu"
          class="hidden absolute right-0 mt-2 w-56 bg-white border rounded shadow z-10 p-3"
        >
          <p class="text-sm font-semibold mb-2">Toggle columns</p>
          <div class="space-y-1 text-sm">
            <label class="flex items-center gap-2">
              <input type="checkbox" data-col="function" checked /> Function
            </label>
            <label class="flex items-center gap-2">
              <input type="checkbox" data-col="dataset" checked /> Dataset
            </label>
            <label class="flex items-center gap-2">
              <input type="checkbox" data-col="labels" checked /> Labels
            </label>
            <label class="flex items-center gap-2">
              <input type="checkbox" data-col="input" checked /> Input
            </label>
            <label class="flex items-center gap-2">
              <input type="checkbox" data-col="output" checked /> Output
            </label>
            <label class="flex items-center gap-2">
              <input type="checkbox" data-col="error" checked /> Error
            </label>
            <label class="flex items-center gap-2">
              <input type="checkbox" data-col="scores" checked /> Scores
            </label>
            <label class="flex items-center gap-2">
              <input type="checkbox" data-col="latency" checked /> Latency
            </label>
          </div>
          <div class="mt-3 border-t pt-3 flex items-center gap-2">
            <button id="reset-columns" class="text-xs px-2 py-1 border rounded">
              Reset Columns
            </button>
            <button id="reset-sorting" class="text-xs px-2 py-1 border rounded">
              Reset Sorting
            </button>
            <button id="reset-widths" class="text-xs px-2 py-1 border rounded">
              Reset Widths
            </button>
          </div>
        </div>
      </div>
    </div>

    <div
      id="results"
      hx-get="/results"
      hx-trigger="load"
      hx-swap="innerHTML"
    ></div>

    <script>
      // Dropdown toggle
      const toggleBtn = document.getElementById("columns-toggle");
      const menuEl = document.getElementById("columns-menu");
      toggleBtn.addEventListener("click", () => {
        menuEl.classList.toggle("hidden");
      });
      document.addEventListener("click", (e) => {
        if (!menuEl.contains(e.target) && e.target !== toggleBtn) {
          menuEl.classList.add("hidden");
        }
      });

      const STORAGE_KEY = "twevals:hidden_columns";
      const SORT_STORAGE_KEY = "twevals:sort_state";
      const WIDTHS_STORAGE_KEY = "twevals:col_widths";
      const EXPANDED_ROW_KEY = "twevals:expanded_row";
      function getHiddenCols() {
        try {
          return JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]");
        } catch {
          return [];
        }
      }
      function setHiddenCols(cols) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(cols));
      }
      function getSortState() {
        try {
          return JSON.parse(localStorage.getItem(SORT_STORAGE_KEY) || "[]");
        } catch {
          return [];
        }
      }
      function setSortState(state) {
        localStorage.setItem(SORT_STORAGE_KEY, JSON.stringify(state));
      }
      function getColWidths() {
        try {
          return JSON.parse(localStorage.getItem(WIDTHS_STORAGE_KEY) || "{}");
        } catch {
          return {};
        }
      }
      function setColWidths(map) {
        localStorage.setItem(WIDTHS_STORAGE_KEY, JSON.stringify(map));
      }
      function applyColumnVisibility() {
        const hidden = new Set(getHiddenCols());
        const resultsTable = document.getElementById("results-table");
        if (!resultsTable) return;
        const allCols = [
          "function",
          "dataset",
          "labels",
          "input",
          "output",
          "error",
          "scores",
          "latency",
        ];
        for (const col of allCols) {
          const isHidden = hidden.has(col);
          const selector = `[data-col="${col}"]`;
          document
            .querySelectorAll(`#results-table thead th${selector}, #results-table tbody td${selector}`)
            .forEach((el) => {
              if (isHidden) el.classList.add("hidden");
              else el.classList.remove("hidden");
            });
        }
        // Sync checkboxes
        document
          .querySelectorAll('#columns-menu input[type="checkbox"][data-col]')
          .forEach((cb) => {
            cb.checked = !hidden.has(cb.getAttribute("data-col"));
          });
      }

      function onToggleCheckbox(e) {
        const col = e.target.getAttribute("data-col");
        const hidden = new Set(getHiddenCols());
        if (e.target.checked) hidden.delete(col);
        else hidden.add(col);
        setHiddenCols([...hidden]);
        applyColumnVisibility();
      }

      // Apply stored column widths
      function applyColumnWidths(table) {
        if (!table) return;
        const widths = getColWidths();
        Object.keys(widths).forEach((col) => {
          const w = widths[col];
          if (!w) return;
          const selector = `[data-col="${col}"]`;
          table
            .querySelectorAll(`thead th${selector}, tbody td${selector}`)
            .forEach((el) => {
              el.style.width = `${w}px`;
              el.style.minWidth = `${w}px`;
              el.style.maxWidth = `${w}px`;
            });
        });
      }

      // Initialize resizers on table headers
      function initResizableColumns(table) {
        if (!table) return;
        const widths = getColWidths();
        const ths = table.querySelectorAll('thead th[data-col]');
        ths.forEach((th) => {
          // Ensure relative positioning for the handle
          if (getComputedStyle(th).position === 'static') {
            th.style.position = 'relative';
          }
          // Avoid duplicating handles if re-initialized
          if (th.querySelector('.col-resizer')) return;

          const handle = document.createElement('div');
          handle.className = 'col-resizer';
          handle.setAttribute('aria-hidden', 'true');
          th.appendChild(handle);

          let startX = 0;
          let startWidth = 0;
          let colKey = th.getAttribute('data-col');

          const minWidth = 60; // px
          const maxWidth = 1000; // px

          function onMouseMove(e) {
            const dx = e.clientX - startX;
            let newW = Math.max(minWidth, Math.min(maxWidth, startWidth + dx));
            const selector = `[data-col="${colKey}"]`;
            table
              .querySelectorAll(`thead th${selector}, tbody td${selector}`)
              .forEach((el) => {
                el.style.width = `${newW}px`;
                el.style.minWidth = `${newW}px`;
                el.style.maxWidth = `${newW}px`;
              });
          }

          function onMouseUp(e) {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            document.body.classList.remove('twevals-col-resize');
            // Persist final width
            const currentWidth = th.getBoundingClientRect().width;
            const map = getColWidths();
            map[colKey] = Math.round(currentWidth);
            setColWidths(map);
          }

          handle.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation(); // don't trigger sort
            startX = e.clientX;
            startWidth = th.getBoundingClientRect().width;
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.body.classList.add('twevals-col-resize');
          });

          // Prevent stray click event triggering sort
          handle.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
          });

          // Apply stored width initially
          const saved = widths[colKey];
          if (saved) {
            const selector = `[data-col="${colKey}"]`;
            table
              .querySelectorAll(`thead th${selector}, tbody td${selector}`)
              .forEach((el) => {
                el.style.width = `${saved}px`;
                el.style.minWidth = `${saved}px`;
                el.style.maxWidth = `${saved}px`;
              });
          }
        });
      }

      // Attach listeners for checkboxes
      document
        .querySelectorAll('#columns-menu input[type="checkbox"][data-col]')
        .forEach((cb) => cb.addEventListener("change", onToggleCheckbox));

      // Reset buttons
      document.getElementById("reset-columns").addEventListener("click", () => {
        setHiddenCols([]);
        applyColumnVisibility();
        menuEl.classList.add("hidden");
      });
      document.getElementById("reset-sorting").addEventListener("click", () => {
        setSortState([]);
        const table = document.getElementById("results-table");
        if (table) applySortState(table);
        menuEl.classList.add("hidden");
      });
      document.getElementById("reset-widths").addEventListener("click", () => {
        setColWidths({});
        const table = document.getElementById("results-table");
        if (!table) return;
        // Remove inline widths
        table.querySelectorAll('th[data-col], td[data-col]').forEach((el) => {
          el.style.width = '';
          el.style.minWidth = '';
          el.style.maxWidth = '';
        });
        menuEl.classList.add("hidden");
      });

      // Multi-column sorting
      const collator = new Intl.Collator(undefined, { numeric: true, sensitivity: "base" });
      function getCellValue(tr, col) {
        const td = tr.querySelector(`td[data-col="${col}"]`);
        if (!td) return "";
        const dv = td.getAttribute("data-value");
        return dv !== null ? dv : td.textContent.trim();
      }
      function parseValue(value, type) {
        if (type === "number") {
          const num = parseFloat(value);
          return isNaN(num) ? Number.POSITIVE_INFINITY : num;
        }
        return value;
      }
      function compareValues(a, b, type) {
        if (type === "number") {
          return a - b;
        }
        return collator.compare(a, b);
      }
      function applySortState(table) {
        const state = getSortState();
        const headers = table.querySelectorAll("thead th[data-col]");
        headers.forEach((th) => th.setAttribute("aria-sort", "none"));
        const tbody = table.querySelector("tbody");
        const mainRows = Array.from(tbody.querySelectorAll("tr[data-row='main']"));
        // store original index for stable sort (only once) on main rows only
        mainRows.forEach((tr, i) => {
          if (!tr.hasAttribute("data-orig-index")) {
            tr.setAttribute("data-orig-index", String(i));
          }
        });

        if (!state.length) {
          // Reset to original order: append main rows with their detail rows
          mainRows
            .slice()
            .sort(
              (a, b) =>
                Number(a.getAttribute("data-orig-index")) -
                Number(b.getAttribute("data-orig-index"))
            )
            .forEach((tr) => {
              const id = tr.getAttribute('data-row-id');
              const detail = tbody.querySelector(`tr[data-row='detail'][data-row-id='${id}']`);
              tbody.appendChild(tr);
              if (detail) tbody.appendChild(detail);
            });
          return;
        }

        // Update header aria-sort
        state.forEach((s) => {
          const th = table.querySelector(`thead th[data-col="${s.col}"]`);
          if (th) th.setAttribute("aria-sort", s.dir === "asc" ? "ascending" : "descending");
        });

        mainRows
          .slice()
          .sort((ra, rb) => {
            for (const s of state) {
              const type = s.type || "string";
              const va = parseValue(getCellValue(ra, s.col), type);
              const vb = parseValue(getCellValue(rb, s.col), type);
              const cmp = compareValues(va, vb, type);
              if (cmp !== 0) return s.dir === "asc" ? cmp : -cmp;
            }
            return (
              Number(ra.getAttribute("data-orig-index")) -
              Number(rb.getAttribute("data-orig-index"))
            );
          })
          .forEach((tr) => {
            const id = tr.getAttribute('data-row-id');
            const detail = tbody.querySelector(`tr[data-row='detail'][data-row-id='${id}']`);
            tbody.appendChild(tr);
            if (detail) tbody.appendChild(detail);
          });
      }

      function toggleSort(table, col, type, multi) {
        let state = getSortState();
        const idx = state.findIndex((s) => s.col === col);
        if (multi) {
          if (idx === -1) state.push({ col, dir: "asc", type });
          else if (state[idx].dir === "asc") state[idx].dir = "desc";
          else state.splice(idx, 1); // remove if toggled past desc
        } else {
          if (idx === 0 && state[0].dir === "asc") state = [{ col, dir: "desc", type }];
          else if (idx === 0 && state[0].dir === "desc") state = [];
          else state = [{ col, dir: "asc", type }];
        }
        setSortState(state);
        applySortState(table);
      }

      // Wire header clicks and initialize after results load/swap
      document.addEventListener("htmx:afterSwap", function (e) {
        if (e.target.id === "results") {
          const table = document.getElementById("results-table");
          if (table) applySortState(table);
          applyColumnVisibility();
          if (table) {
            applyColumnWidths(table);
            initResizableColumns(table);
          }
          initExpandHandlers();
          initInlineEditing();
          restoreExpandedRow();
          wireExportButtons();
        }
      });

      // Delegate click on table headers for sorting (supports Shift+click)
      document.addEventListener("click", function (e) {
        const th = e.target.closest("#results thead th[data-col]");
        if (!th) return;
        const table = document.getElementById("results-table");
        if (!table) return;
        const col = th.getAttribute("data-col");
        const type = th.getAttribute("data-type") || "string";
        toggleSort(table, col, type, e.shiftKey);
      });

      // Expand/collapse logic
      function initExpandHandlers() {
        const container = document.getElementById('results');
        if (!container) return;
        const tbody = document.querySelector('#results-table tbody');
        if (!tbody) return;

        function closeAll() {
          tbody.querySelectorAll("tr[data-row='detail']").forEach((tr) => tr.setAttribute('hidden', ''));
          container.querySelectorAll('.expand-btn[aria-expanded="true"]').forEach((b) => {
            b.setAttribute('aria-expanded', 'false');
            const icon = b.querySelector('.icon');
            if (icon) icon.textContent = '▸';
          });
        }

        function openRow(rowId) {
          const detail = tbody.querySelector(`tr[data-row='detail'][data-row-id='${rowId}']`);
          const btn = container.querySelector(`.expand-btn[data-row-id='${rowId}']`);
          if (!detail || !btn) return;
          closeAll();
          detail.removeAttribute('hidden');
          btn.setAttribute('aria-expanded', 'true');
          const icon = btn.querySelector('.icon');
          if (icon) icon.textContent = '▾';
          try { localStorage.setItem(EXPANDED_ROW_KEY, rowId); } catch {}
        }

        container.querySelectorAll('.expand-btn').forEach((btn) => {
          // Remove previous listener by cloning
          const clone = btn.cloneNode(true);
          btn.parentNode.replaceChild(clone, btn);
          clone.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const rowId = clone.getAttribute('data-row-id');
            const detail = tbody.querySelector(`tr[data-row='detail'][data-row-id='${rowId}']`);
            const isOpen = detail && !detail.hasAttribute('hidden');
            if (isOpen) {
              closeAll();
              try { localStorage.removeItem(EXPANDED_ROW_KEY); } catch {}
            } else {
              openRow(rowId);
            }
          });
        });

        // helper to restore after refresh
        window.restoreExpandedRow = function restoreExpandedRow() {
          let rowId = null;
          try { rowId = localStorage.getItem(EXPANDED_ROW_KEY); } catch {}
          if (rowId) openRow(rowId);
        }
      }

      // Inline editing logic
      function initInlineEditing() {
        const container = document.getElementById('results');
        const table = document.getElementById('results-table');
        if (!container || !table) return;
        const runId = table.getAttribute('data-run-id') || 'latest';

        container.querySelectorAll('.edit-btn').forEach((btn) => {
          const rowId = btn.getAttribute('data-row-id');
          const detail = container.querySelector(`tr[data-row='detail'][data-row-id='${rowId}']`);
          const saveBtn = container.querySelector(`.save-btn[data-row-id='${rowId}']`);
          const cancelBtn = container.querySelector(`.cancel-btn[data-row-id='${rowId}']`);
          if (!detail || !saveBtn || !cancelBtn) return;

          btn.addEventListener('click', () => enterEdit(rowId));
          cancelBtn.addEventListener('click', () => exitEdit(rowId, true));
          saveBtn.addEventListener('click', () => saveEdit(rowId, runId));
        });

        function toggleEditUI(detail, editing) {
          detail.querySelectorAll('.view-section').forEach((el) => el.classList.toggle('hidden', editing));
          detail.querySelectorAll('.edit-section').forEach((el) => el.classList.toggle('hidden', !editing));
          const rowId = detail.getAttribute('data-row-id');
          const editBtn = container.querySelector(`.edit-btn[data-row-id='${rowId}']`);
          const saveBtn = container.querySelector(`.save-btn[data-row-id='${rowId}']`);
          const cancelBtn = container.querySelector(`.cancel-btn[data-row-id='${rowId}']`);
          if (editBtn && saveBtn && cancelBtn) {
            editBtn.classList.toggle('hidden', editing);
            saveBtn.classList.toggle('hidden', !editing);
            cancelBtn.classList.toggle('hidden', !editing);
          }
        }

        function enterEdit(rowId) {
          const detail = container.querySelector(`tr[data-row='detail'][data-row-id='${rowId}']`);
          if (!detail) return;
          toggleEditUI(detail, true);
          // Initialize inputs from original data attributes if needed
          const ds = detail.getAttribute('data-original-dataset') || '';
          const lbls = JSON.parse(detail.getAttribute('data-original-labels') || '[]');
          const md = JSON.parse(detail.getAttribute('data-original-metadata') || 'null');
          const dsInput = detail.querySelector(`#dataset-input-${rowId}`);
          const lbInput = detail.querySelector(`#labels-input-${rowId}`);
          const mdInput = detail.querySelector(`#metadata-input-${rowId}`);
          if (dsInput) dsInput.value = ds;
          if (lbInput) lbInput.value = (lbls || []).join(', ');
          if (mdInput) mdInput.value = md ? JSON.stringify(md, null, 2) : '';
        }

        function exitEdit(rowId, resetValues) {
          const detail = container.querySelector(`tr[data-row='detail'][data-row-id='${rowId}']`);
          if (!detail) return;
          if (resetValues) {
            const ds = detail.getAttribute('data-original-dataset') || '';
            const lbls = JSON.parse(detail.getAttribute('data-original-labels') || '[]');
            const md = JSON.parse(detail.getAttribute('data-original-metadata') || 'null');
            const dsInput = detail.querySelector(`#dataset-input-${rowId}`);
            const lbInput = detail.querySelector(`#labels-input-${rowId}`);
            const mdInput = detail.querySelector(`#metadata-input-${rowId}`);
            if (dsInput) dsInput.value = ds;
            if (lbInput) lbInput.value = (lbls || []).join(', ');
            if (mdInput) mdInput.value = md ? JSON.stringify(md, null, 2) : '';
            // reset scores inputs
            const scores = JSON.parse(detail.getAttribute('data-original-scores') || '[]');
            const editor = detail.querySelector(`#scores-editor-${rowId}`);
            if (editor) {
              const cards = editor.querySelectorAll('.border.rounded.p-2.bg-gray-50');
              cards.forEach((card, i) => {
                const s = scores[i];
                if (!s) return;
                const k = card.querySelector('[name="score-key"]');
                const v = card.querySelector('[name="score-value"]');
                const p = card.querySelector('[name="score-passed"]');
                const n = card.querySelector('[name="score-notes"]');
                if (k) k.value = s.key || '';
                if (v) v.value = (s.value ?? '');
                if (p) p.value = (s.passed === true ? 'true' : s.passed === false ? 'false' : '');
                if (n) n.value = (s.notes ?? '');
              });
            }
          }
          toggleEditUI(detail, false);
        }

        async function saveEdit(rowId, runId) {
          const detail = container.querySelector(`tr[data-row='detail'][data-row-id='${rowId}']`);
          if (!detail) return;
          const dsInput = detail.querySelector(`#dataset-input-${rowId}`);
          const lbInput = detail.querySelector(`#labels-input-${rowId}`);
          const mdInput = detail.querySelector(`#metadata-input-${rowId}`);
          const editor = detail.querySelector(`#scores-editor-${rowId}`);

          let metadata = null;
          const mdRaw = (mdInput && mdInput.value.trim()) || '';
          if (mdRaw) {
            try { metadata = JSON.parse(mdRaw); }
            catch (e) { alert('Invalid metadata JSON'); return; }
          }

          // Build scores payload
          const scorePayload = [];
          if (editor) {
            editor.querySelectorAll('.border.rounded.p-2.bg-gray-50').forEach((card) => {
              const k = card.querySelector('[name="score-key"]').value.trim();
              const vRaw = card.querySelector('[name="score-value"]').value.trim();
              const pVal = card.querySelector('[name="score-passed"]').value;
              const nVal = card.querySelector('[name="score-notes"]').value.trim();
              const s = { key: k };
              if (vRaw !== '') {
                const num = Number(vRaw);
                if (!Number.isNaN(num)) s.value = num;
              }
              if (pVal === 'true') s.passed = true;
              else if (pVal === 'false') s.passed = false;
              if (nVal !== '') s.notes = nVal;
              // only include if has key and at least value/passed/notes
              if (s.key && (s.value !== undefined || s.passed !== undefined || s.notes !== undefined)) {
                scorePayload.push(s);
              }
            });
          }

          const payload = {
            dataset: dsInput ? dsInput.value.trim() : undefined,
            labels: lbInput ? lbInput.value.split(',').map(x => x.trim()).filter(Boolean) : undefined,
            result: {
              metadata: metadata,
              scores: scorePayload
            }
          };

          try {
            const resp = await fetch(`/api/runs/${runId}/results/${rowId}`, {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });
            if (!resp.ok) {
              const t = await resp.text();
              throw new Error(t || 'Failed to save');
            }
          } catch (e) {
            alert(`Save failed: ${e}`);
            return;
          }

          // Refresh the results panel to reflect changes
          const results = document.getElementById('results');
          if (results) {
            try { localStorage.setItem(EXPANDED_ROW_KEY, rowId); } catch {}
            htmx.ajax('GET', '/results', { target: '#results', swap: 'innerHTML' });
          }
        }
      }

      // Annotation handlers
      document.addEventListener('click', async (e) => {
        const btnAdd = e.target.closest('.ann-add');
        if (btnAdd) {
          const rowId = btnAdd.getAttribute('data-row-id');
          const table = document.getElementById('results-table');
          const runId = table.getAttribute('data-run-id') || 'latest';
          const text = document.getElementById(`ann-new-text-${rowId}`).value.trim();
          if (!text) return;
          try {
            const resp = await fetch(`/api/runs/${runId}/results/${rowId}/annotations`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ text })
            });
            if (!resp.ok) throw new Error(await resp.text());
          } catch (err) {
            alert(`Add annotation failed: ${err}`);
            return;
          }
          try { localStorage.setItem(EXPANDED_ROW_KEY, rowId); } catch {}
          htmx.ajax('GET', '/results', { target: '#results', swap: 'innerHTML' });
          return;
        }

        const btnEdit = e.target.closest('.ann-edit');
        if (btnEdit) {
          const rowId = btnEdit.getAttribute('data-row-id');
          const idx = btnEdit.getAttribute('data-ann-index');
          const li = document.querySelector(`tr[data-row='detail'][data-row-id='${rowId}'] li[data-ann-index='${idx}']`);
          if (!li) return;
          li.querySelector('.view-ann')?.classList.add('hidden');
          li.querySelector('.edit-ann')?.classList.remove('hidden');
          btnEdit.classList.add('hidden');
          li.querySelector('.ann-save')?.classList.remove('hidden');
          li.querySelector('.ann-cancel')?.classList.remove('hidden');
          return;
        }

        const btnCancel = e.target.closest('.ann-cancel');
        if (btnCancel) {
          const rowId = btnCancel.getAttribute('data-row-id');
          const idx = btnCancel.getAttribute('data-ann-index');
          const li = document.querySelector(`tr[data-row='detail'][data-row-id='${rowId}'] li[data-ann-index='${idx}']`);
          if (!li) return;
          li.querySelector('.view-ann')?.classList.remove('hidden');
          li.querySelector('.edit-ann')?.classList.add('hidden');
          li.querySelector('.ann-edit')?.classList.remove('hidden');
          li.querySelector('.ann-save')?.classList.add('hidden');
          btnCancel.classList.add('hidden');
          return;
        }

        const btnSave = e.target.closest('.ann-save');
        if (btnSave) {
          const rowId = btnSave.getAttribute('data-row-id');
          const idx = btnSave.getAttribute('data-ann-index');
          const table = document.getElementById('results-table');
          const runId = table.getAttribute('data-run-id') || 'latest';
          const li = document.querySelector(`tr[data-row='detail'][data-row-id='${rowId}'] li[data-ann-index='${idx}']`);
          const text = li.querySelector('[name="ann-text"]').value.trim();
          try {
            const resp = await fetch(`/api/runs/${runId}/results/${rowId}/annotations/${idx}`, {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ text })
            });
            if (!resp.ok) throw new Error(await resp.text());
          } catch (err) {
            alert(`Update annotation failed: ${err}`);
            return;
          }
          try { localStorage.setItem(EXPANDED_ROW_KEY, rowId); } catch {}
          htmx.ajax('GET', '/results', { target: '#results', swap: 'innerHTML' });
          return;
        }

        const btnDelete = e.target.closest('.ann-delete');
        if (btnDelete) {
          const rowId = btnDelete.getAttribute('data-row-id');
          const idx = btnDelete.getAttribute('data-ann-index');
          const table = document.getElementById('results-table');
          const runId = table.getAttribute('data-run-id') || 'latest';
          try {
            const resp = await fetch(`/api/runs/${runId}/results/${rowId}/annotations/${idx}`, {
              method: 'DELETE'
            });
            if (!resp.ok) throw new Error(await resp.text());
          } catch (err) {
            alert(`Delete annotation failed: ${err}`);
            return;
          }
          try { localStorage.setItem(EXPANDED_ROW_KEY, rowId); } catch {}
          htmx.ajax('GET', '/results', { target: '#results', swap: 'innerHTML' });
          return;
        }
      });

      function wireExportButtons() {
        const table = document.getElementById('results-table');
        const runId = table ? (table.getAttribute('data-run-id') || 'latest') : 'latest';
        const jsonBtn = document.getElementById('export-json');
        const csvBtn = document.getElementById('export-csv');
        if (jsonBtn) {
          jsonBtn.onclick = () => {
            window.location.href = `/api/runs/${runId}/export/json`;
          };
        }
        if (csvBtn) {
          csvBtn.onclick = () => {
            window.location.href = `/api/runs/${runId}/export/csv`;
          };
        }
      }
    </script>
  </body>
  </html>
