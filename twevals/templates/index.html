<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Twevals Results</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Visual indicators for sort direction on headers */
      #results-table thead th[aria-sort="ascending"]::after {
        content: " ▲";
        font-size: 0.75rem; /* text-sm */
        color: #6b7280; /* gray-500 */
      }
      #results-table thead th[aria-sort="descending"]::after {
        content: " ▼";
        font-size: 0.75rem; /* text-sm */
        color: #6b7280; /* gray-500 */
      }
      /* Column resizer handle */
      #results-table thead th .col-resizer {
        position: absolute;
        right: 0;
        top: 0;
        width: 6px;
        height: 100%;
        cursor: col-resize;
        user-select: none;
      }
      #results-table thead th .col-resizer:hover {
        background: linear-gradient(to right, transparent, rgba(0,0,0,0.05));
      }
      body.twevals-col-resize {
        cursor: col-resize !important;
      }
    </style>
  </head>
  <body class="p-4">
    <div class="flex items-center gap-2 mb-4">
      <h1 class="text-2xl font-bold mr-auto">Twevals Results</h1>
      <button
        class="px-4 py-2 bg-blue-500 text-white rounded"
        hx-get="/results"
        hx-target="#results"
        hx-swap="innerHTML"
      >
        Refresh
      </button>
      <div class="relative">
        <button id="columns-toggle" class="px-3 py-2 bg-gray-100 border rounded">
          Columns ▾
        </button>
        <div
          id="columns-menu"
          class="hidden absolute right-0 mt-2 w-56 bg-white border rounded shadow z-10 p-3"
        >
          <p class="text-sm font-semibold mb-2">Toggle columns</p>
          <div class="space-y-1 text-sm">
            <label class="flex items-center gap-2">
              <input type="checkbox" data-col="function" checked /> Function
            </label>
            <label class="flex items-center gap-2">
              <input type="checkbox" data-col="dataset" checked /> Dataset
            </label>
            <label class="flex items-center gap-2">
              <input type="checkbox" data-col="labels" checked /> Labels
            </label>
            <label class="flex items-center gap-2">
              <input type="checkbox" data-col="input" checked /> Input
            </label>
            <label class="flex items-center gap-2">
              <input type="checkbox" data-col="output" checked /> Output
            </label>
            <label class="flex items-center gap-2">
              <input type="checkbox" data-col="error" checked /> Error
            </label>
            <label class="flex items-center gap-2">
              <input type="checkbox" data-col="status" checked /> Pass
            </label>
            <label class="flex items-center gap-2">
              <input type="checkbox" data-col="latency" checked /> Latency
            </label>
          </div>
          <div class="mt-3 border-t pt-3 flex items-center gap-2">
            <button id="reset-columns" class="text-xs px-2 py-1 border rounded">
              Reset Columns
            </button>
            <button id="reset-sorting" class="text-xs px-2 py-1 border rounded">
              Reset Sorting
            </button>
            <button id="reset-widths" class="text-xs px-2 py-1 border rounded">
              Reset Widths
            </button>
          </div>
        </div>
      </div>
    </div>

    <div
      id="results"
      hx-get="/results"
      hx-trigger="load"
      hx-swap="innerHTML"
    ></div>

    <script>
      // Dropdown toggle
      const toggleBtn = document.getElementById("columns-toggle");
      const menuEl = document.getElementById("columns-menu");
      toggleBtn.addEventListener("click", () => {
        menuEl.classList.toggle("hidden");
      });
      document.addEventListener("click", (e) => {
        if (!menuEl.contains(e.target) && e.target !== toggleBtn) {
          menuEl.classList.add("hidden");
        }
      });

      const STORAGE_KEY = "twevals:hidden_columns";
      const SORT_STORAGE_KEY = "twevals:sort_state";
      const WIDTHS_STORAGE_KEY = "twevals:col_widths";
      function getHiddenCols() {
        try {
          return JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]");
        } catch {
          return [];
        }
      }
      function setHiddenCols(cols) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(cols));
      }
      function getSortState() {
        try {
          return JSON.parse(localStorage.getItem(SORT_STORAGE_KEY) || "[]");
        } catch {
          return [];
        }
      }
      function setSortState(state) {
        localStorage.setItem(SORT_STORAGE_KEY, JSON.stringify(state));
      }
      function getColWidths() {
        try {
          return JSON.parse(localStorage.getItem(WIDTHS_STORAGE_KEY) || "{}");
        } catch {
          return {};
        }
      }
      function setColWidths(map) {
        localStorage.setItem(WIDTHS_STORAGE_KEY, JSON.stringify(map));
      }
      function applyColumnVisibility() {
        const hidden = new Set(getHiddenCols());
        const resultsTable = document.getElementById("results-table");
        if (!resultsTable) return;
        const allCols = [
          "function",
          "dataset",
          "labels",
          "input",
          "output",
          "error",
          "status",
          "latency",
        ];
        for (const col of allCols) {
          const isHidden = hidden.has(col);
          const selector = `[data-col="${col}"]`;
          document
            .querySelectorAll(`#results-table thead th${selector}, #results-table tbody td${selector}`)
            .forEach((el) => {
              if (isHidden) el.classList.add("hidden");
              else el.classList.remove("hidden");
            });
        }
        // Sync checkboxes
        document
          .querySelectorAll('#columns-menu input[type="checkbox"][data-col]')
          .forEach((cb) => {
            cb.checked = !hidden.has(cb.getAttribute("data-col"));
          });
      }

      function onToggleCheckbox(e) {
        const col = e.target.getAttribute("data-col");
        const hidden = new Set(getHiddenCols());
        if (e.target.checked) hidden.delete(col);
        else hidden.add(col);
        setHiddenCols([...hidden]);
        applyColumnVisibility();
      }

      // Apply stored column widths
      function applyColumnWidths(table) {
        if (!table) return;
        const widths = getColWidths();
        Object.keys(widths).forEach((col) => {
          const w = widths[col];
          if (!w) return;
          const selector = `[data-col="${col}"]`;
          table
            .querySelectorAll(`thead th${selector}, tbody td${selector}`)
            .forEach((el) => {
              el.style.width = `${w}px`;
              el.style.minWidth = `${w}px`;
              el.style.maxWidth = `${w}px`;
            });
        });
      }

      // Initialize resizers on table headers
      function initResizableColumns(table) {
        if (!table) return;
        const widths = getColWidths();
        const ths = table.querySelectorAll('thead th[data-col]');
        ths.forEach((th) => {
          // Ensure relative positioning for the handle
          if (getComputedStyle(th).position === 'static') {
            th.style.position = 'relative';
          }
          // Avoid duplicating handles if re-initialized
          if (th.querySelector('.col-resizer')) return;

          const handle = document.createElement('div');
          handle.className = 'col-resizer';
          handle.setAttribute('aria-hidden', 'true');
          th.appendChild(handle);

          let startX = 0;
          let startWidth = 0;
          let colKey = th.getAttribute('data-col');

          const minWidth = 60; // px
          const maxWidth = 1000; // px

          function onMouseMove(e) {
            const dx = e.clientX - startX;
            let newW = Math.max(minWidth, Math.min(maxWidth, startWidth + dx));
            const selector = `[data-col="${colKey}"]`;
            table
              .querySelectorAll(`thead th${selector}, tbody td${selector}`)
              .forEach((el) => {
                el.style.width = `${newW}px`;
                el.style.minWidth = `${newW}px`;
                el.style.maxWidth = `${newW}px`;
              });
          }

          function onMouseUp(e) {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            document.body.classList.remove('twevals-col-resize');
            // Persist final width
            const currentWidth = th.getBoundingClientRect().width;
            const map = getColWidths();
            map[colKey] = Math.round(currentWidth);
            setColWidths(map);
          }

          handle.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation(); // don't trigger sort
            startX = e.clientX;
            startWidth = th.getBoundingClientRect().width;
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.body.classList.add('twevals-col-resize');
          });

          // Prevent stray click event triggering sort
          handle.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
          });

          // Apply stored width initially
          const saved = widths[colKey];
          if (saved) {
            const selector = `[data-col="${colKey}"]`;
            table
              .querySelectorAll(`thead th${selector}, tbody td${selector}`)
              .forEach((el) => {
                el.style.width = `${saved}px`;
                el.style.minWidth = `${saved}px`;
                el.style.maxWidth = `${saved}px`;
              });
          }
        });
      }

      // Attach listeners for checkboxes
      document
        .querySelectorAll('#columns-menu input[type="checkbox"][data-col]')
        .forEach((cb) => cb.addEventListener("change", onToggleCheckbox));

      // Reset buttons
      document.getElementById("reset-columns").addEventListener("click", () => {
        setHiddenCols([]);
        applyColumnVisibility();
        menuEl.classList.add("hidden");
      });
      document.getElementById("reset-sorting").addEventListener("click", () => {
        setSortState([]);
        const table = document.getElementById("results-table");
        if (table) applySortState(table);
        menuEl.classList.add("hidden");
      });
      document.getElementById("reset-widths").addEventListener("click", () => {
        setColWidths({});
        const table = document.getElementById("results-table");
        if (!table) return;
        // Remove inline widths
        table.querySelectorAll('th[data-col], td[data-col]').forEach((el) => {
          el.style.width = '';
          el.style.minWidth = '';
          el.style.maxWidth = '';
        });
        menuEl.classList.add("hidden");
      });

      // Multi-column sorting
      const collator = new Intl.Collator(undefined, { numeric: true, sensitivity: "base" });
      function getCellValue(tr, col) {
        const td = tr.querySelector(`td[data-col="${col}"]`);
        if (!td) return "";
        const dv = td.getAttribute("data-value");
        return dv !== null ? dv : td.textContent.trim();
      }
      function parseValue(value, type) {
        if (type === "number") {
          const num = parseFloat(value);
          return isNaN(num) ? Number.POSITIVE_INFINITY : num;
        }
        return value;
      }
      function compareValues(a, b, type) {
        if (type === "number") {
          return a - b;
        }
        return collator.compare(a, b);
      }
      function applySortState(table) {
        const state = getSortState();
        const headers = table.querySelectorAll("thead th[data-col]");
        headers.forEach((th) => th.setAttribute("aria-sort", "none"));
        const tbody = table.querySelector("tbody");
        const mainRows = Array.from(tbody.querySelectorAll("tr[data-row='main']"));
        // store original index for stable sort (only once) on main rows only
        mainRows.forEach((tr, i) => {
          if (!tr.hasAttribute("data-orig-index")) {
            tr.setAttribute("data-orig-index", String(i));
          }
        });

        if (!state.length) {
          // Reset to original order: append main rows with their detail rows
          mainRows
            .slice()
            .sort(
              (a, b) =>
                Number(a.getAttribute("data-orig-index")) -
                Number(b.getAttribute("data-orig-index"))
            )
            .forEach((tr) => {
              const id = tr.getAttribute('data-row-id');
              const detail = tbody.querySelector(`tr[data-row='detail'][data-row-id='${id}']`);
              tbody.appendChild(tr);
              if (detail) tbody.appendChild(detail);
            });
          return;
        }

        // Update header aria-sort
        state.forEach((s) => {
          const th = table.querySelector(`thead th[data-col="${s.col}"]`);
          if (th) th.setAttribute("aria-sort", s.dir === "asc" ? "ascending" : "descending");
        });

        mainRows
          .slice()
          .sort((ra, rb) => {
            for (const s of state) {
              const type = s.type || "string";
              const va = parseValue(getCellValue(ra, s.col), type);
              const vb = parseValue(getCellValue(rb, s.col), type);
              const cmp = compareValues(va, vb, type);
              if (cmp !== 0) return s.dir === "asc" ? cmp : -cmp;
            }
            return (
              Number(ra.getAttribute("data-orig-index")) -
              Number(rb.getAttribute("data-orig-index"))
            );
          })
          .forEach((tr) => {
            const id = tr.getAttribute('data-row-id');
            const detail = tbody.querySelector(`tr[data-row='detail'][data-row-id='${id}']`);
            tbody.appendChild(tr);
            if (detail) tbody.appendChild(detail);
          });
      }

      function toggleSort(table, col, type, multi) {
        let state = getSortState();
        const idx = state.findIndex((s) => s.col === col);
        if (multi) {
          if (idx === -1) state.push({ col, dir: "asc", type });
          else if (state[idx].dir === "asc") state[idx].dir = "desc";
          else state.splice(idx, 1); // remove if toggled past desc
        } else {
          if (idx === 0 && state[0].dir === "asc") state = [{ col, dir: "desc", type }];
          else if (idx === 0 && state[0].dir === "desc") state = [];
          else state = [{ col, dir: "asc", type }];
        }
        setSortState(state);
        applySortState(table);
      }

      // Wire header clicks and initialize after results load/swap
      document.addEventListener("htmx:afterSwap", function (e) {
        if (e.target.id === "results") {
          const table = document.getElementById("results-table");
          if (table) applySortState(table);
          applyColumnVisibility();
          if (table) {
            applyColumnWidths(table);
            initResizableColumns(table);
          }
          initExpandHandlers();
        }
      });

      // Delegate click on table headers for sorting (supports Shift+click)
      document.addEventListener("click", function (e) {
        const th = e.target.closest("#results thead th[data-col]");
        if (!th) return;
        const table = document.getElementById("results-table");
        if (!table) return;
        const col = th.getAttribute("data-col");
        const type = th.getAttribute("data-type") || "string";
        toggleSort(table, col, type, e.shiftKey);
      });

      // Expand/collapse logic
      function initExpandHandlers() {
        const container = document.getElementById('results');
        if (!container) return;
        container.querySelectorAll('.expand-btn').forEach((btn) => {
          // Remove previous listener by cloning
          const clone = btn.cloneNode(true);
          btn.parentNode.replaceChild(clone, btn);
          clone.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const rowId = clone.getAttribute('data-row-id');
            const tbody = document.querySelector('#results-table tbody');
            if (!tbody) return;
            const detail = tbody.querySelector(`tr[data-row='detail'][data-row-id='${rowId}']`);
            const isOpen = detail && !detail.hasAttribute('hidden');

            // Close any open detail rows and reset icons
            tbody.querySelectorAll("tr[data-row='detail']").forEach((tr) => {
              tr.setAttribute('hidden', '');
            });
            container.querySelectorAll('.expand-btn[aria-expanded="true"]').forEach((b) => {
              b.setAttribute('aria-expanded', 'false');
              const icon = b.querySelector('.icon');
              if (icon) icon.textContent = '▸';
            });

            // Toggle this one
            if (detail) {
              if (!isOpen) {
                detail.removeAttribute('hidden');
                clone.setAttribute('aria-expanded', 'true');
                const icon = clone.querySelector('.icon');
                if (icon) icon.textContent = '▾';
              } else {
                detail.setAttribute('hidden', '');
                clone.setAttribute('aria-expanded', 'false');
                const icon = clone.querySelector('.icon');
                if (icon) icon.textContent = '▸';
              }
            }
          });
        });
      }
    </script>
  </body>
  </html>
